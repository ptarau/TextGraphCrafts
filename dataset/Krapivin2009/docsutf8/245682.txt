--T
Generation of High Quality Tests for Robustly Untestable Path Delay Faults.
--A
AbstractIn many designs a large portion of path delay faults is not robustly testable. In this paper, we investigate testing strategies for robustly untestable faults. We show that the quality of nonrobust tests may be very poor in detecting small defects caused by manufacturing process variation. We demonstrate that better quality nonrobust tests can be obtained by including timing information into the process of test generation. A good nonrobust test can tolerate larger timing variations on the off-inputs. We also show that not all nonrobustly untestable path delay faults may be ignored in high quality delay testing. Functional sensitizable paths are nonrobustly untestable but, under some faulty conditions, may degrade the performance of the circuit. However, up till now, there was no strategy for generating tests for such faults.In this paper, we present algorithms for generating high quality nonrobust and functional sensitizable tests. We also devise an algorithm for generating tests for validatable nonrobust faults which have a high quality in detecting defects but are hard to be generated automatically. Our experimental results show that the quality of delay testing increases if validatable and high quality nonrobust tests, as well as tests for functional sensitizable path delay faults are included.
--B
Introduction
The objective of delay testing is to detect timing defects which could degrade the circuit's
performance. Two fault models are commonly used for timing defects: the gate delay fault
model [24, 25] and the path delay fault model [16, 22, 17]. The path delay fault model
assumes that the propagation delay of a target path exceeds the clock period while the gate
delay fault model assumes that the propagation delay of a gate/node exceeds its specified
limit. There are pros and cons for both models and they have been discussed in many articles
(e.g., [11]) and will not be repeated here. In this paper, we use the path delay fault model.
In order to test a path for timing defects an input vector pair needs to be
applied. The first vector initializes the circuit, while the second causes the desired transitions.
After a clock period from the time when the second input vector was applied, the values
on the primary outputs are observed and compared to the prestored response of a
circuit to determine if there is a defect.
Path Delay Fault Classification. There are two conditions that can be imposed on
tests for path delay faults: the robust (R) condition and the non-robust (NR) condition. A
robust test [22, 17] guarantees the detection of a fault on the target path regardless of the
delays on all other signals in the circuit. Results reported in [17] and [6] show that for many
benchmark and industrial circuits a large number of faults does not have any robust test.
These faults are called robustly untestable faults. In Table 1 we cite the results reported
in [6] for ISCAS 85 benchmark circuits and some industrial circuits. The number of robustly
untestable faults is shown in column 3. The non-robust condition is less stringent than the
robust condition. A non-robust test will detect delay defects in the target path if the arrival
times of all off-input signals (an on-input is a connection between two gates in the path,
while an off-input is a connection to a gate in the path but it does not belong to the path)
are not late. However, if any of them is late, the test may become invalid. Faults that do
not have any non-robust test are called non-robustly untestable. The results for benchmark
and industrial circuits reported in [6] (column 4 of Table 1) indicate that for most of the
circuits, a high percentage of paths is non-robustly untestable.
Circuit number of long identified untestable faults
paths considered robust (%) non-robust (%)
conv1 57.9K 75.7 43.8

Table

1: Results reported by DYNAMITE [6].
The question whether or not all of the non-robustly untestable faults need to be tested,
has been addressed in [3]. It was shown that some of the non-robustly untestable paths
should be tested and some need not be. A path does not need to be tested if it never
determines the circuit's performance considering all possible timing defects. Such a path
is called functional unsensitizable (FUS) or functional redundant path (FR). A sufficient
condition for functional redundant faults and an efficient algorithm for identifying them
were presented in [3]. Functional sensitizable (FS) paths [3, 8, 9, 23] are untestable under the
non-robust condition but may affect the performance of the circuit and therefore should be
tested. Robust, non-robust and functional sensitizable faults make up the class of functional
irredundant faults (FIRR). Even though the set of non-robust faults, as defined in previous
literature [17] is a superset of the set of robust faults, from now on in this paper, under non-robust
path delay faults we will assume only the set of robustly untestable but non-robustly
testable faults. However, we refer to the set of non-robustly untestable faults as earlier
defined. Also, even though the set of functional sensitizable faults, as defined in [3, 8, 9, 23]
is a superset of the set of non-robust faults, under functional sensitizable path delay faults,
in this paper, we will assume only the non-robustly untestable but functionally sensitizable
faults. Figure 1 shows the classification of path delay faults used in this paper.
Path Delay Faults
FR
R NR FS
FIRR

Figure

1: Classification of path delay faults.
To achieve high quality delay testing, the problem of the test sets generated under existing
testing conditions not being able to detect some of the timing defects has to be dealt with.
Prior Work. Synthesis for robust delay testability [21, 4, 5, 19, 13, 7, 1] is one possible
solution. Research in this direction attempts to synthesize a circuit such that every path is
robustly testable. However, synthesizing a 100% robustly testable circuit usually requires
more logic and/or more primary inputs. Therefore, it may not be a feasible solution for
certain designs. Also, most of the time, resynthesis for testability degrades the performance
of the designs and, therefore, may not be acceptable for many high performance designs.
Contributions. In this paper, we attempt to solve the above problem by test generation.
Our objective is to generate a high quality test for a path delay fault under the most stringent
condition under which a test exists. To implement this strategy, we need to develop test
generation methods for non-robust and functional sensitizable paths:
ffl A non-robustly testable path often can be tested with many different non-robust (NR)
tests. In this paper, we show that some non-robust tests have a higher quality than
the others. Existing methods for non-robust test generation cannot differentiate these
tests. We show that higher quality non-robust tests can be generated by including
timing information into the test derivation process and we present an algorithm for
generating high quality non-robust tests. We introduce a metric, called robustness for
a non-robust test and we use it to measure how far a given NR test is from a robust
test. For each non-robustly testable fault, we attempt to generate a non-robust test
which is closer to a robust test.
ffl A non-robust test for a given target path becomes invalid if certain other paths are
defective. If we can robustly test those faults that may invalidate the non-robust test
for the target path, that non-robust test along with the robust tests for the off-paths
forms a validatable non-robust test (VNR) for the target fault [20]. The validatable non-robust
tests guarantee to detect a fault and therefore, should be used for non-robustly
testable paths whenever they exist. There has been no method proposed for automatic
generation of such tests. In this paper, we present an algorithm for generating tests
for VNR paths.
ffl Functional sensitizable faults have been addressed in [3, 8, 9, 23]. However, no practical
strategy has been proposed for testing such faults for multilevel circuit representations.
In this paper, we devise an algorithm for generating test vectors for functional sensiti-
zable paths.
The paper is organized as follows. In section 2 we describe an experiment designed to
compare the effectiveness of different test sets in detecting delay defects. Section 3 contains
all the necessary definitions. Generation of high quality non-robust tests is addressed in
section 4 while section 5 deals with test generation for functional sensitizable faults. Section 6
shows the experimental results. Section 7 concludes the paper.
An Experiment
To give a clear motivation for this work, we designed and conducted an experiment for
evaluating the quality of delay testing using existing testing strategies.
Definitions. In this work we consider only circuits with AND, NAND, OR, NOR and
NOT gates, i.e., complex gates, as XOR and XNOR, are assumed to be represented using
these simple gates. An input to a gate is said to have a controlling value (denoted as cv)
if it determines the value of the gate's output regardless of the values on the other fanins
to the same gate. If the value on some input is a complement of the controlling value, the
input is said to have a non-controlling value (denoted as ncv). For example, in the case of
an AND or NAND gate, the controlling value is 0 and the non-controlling value is 1, while
for an OR or NOR gate the controlling value is 1 and the non-controlling value is 0. We
define sensitization using the exact sensitization criterion [10]. Hence, we say that a vector
pair sensitizes a path if and only if each on-input is either the earliest controlling input or it
is the latest non-controlling input with all its off-inputs being non-controlling too.
Given a logic circuit C, each gate and connection of C is associated with a propagation
delay (which can be a number or a range). An implementation of C that has the same
circuit structure as C but may have different propagation delays at signals is referred to
as an instance F of C. The presence of different propagation delays will result in different
instances and they can be considered as models for different manufactured chips. Given a
logic design, those instances that do not have any sensitizable path longer than the clock
period - are referred to as good instances. Otherwise, they are delay-defective instances. The
instance with nominal delays on the signals is called
Experiment Description. To mimic the manufacturing process variation in our exper-
iment, for each logic circuit under test we generated a large number of instances. These
instances were then used for delay testing. All generated instances for one circuit differed
only in the propagation delays on the signals.
In our experiments, the nominal propagation delay for each signal and each gate was
given. We assumed that the propagation delay at each signal was a random variable of a
normal distribution. The mean was the given nominal propagation delay and the standard
deviation was also given. We used a random number generator (for a normal distribution of
a given mean and standard deviation) to generate the propagation delay for each signal.
For each generated instance, we used a timing analyzer [2] to identify the longest sensitiz-
able path and to calculate the propagation delay along that path. This number was referred
to as the delay of an instance. Curve (a) in Figure 2 shows the distribution of the delays
for 8,000 generated instances for circuit c880. The nominal propagation delay at each signal
for c880 was obtained from [18] and the standard deviation of the propagation delay at each
signal was assumed to be 1/6 of the nominal propagation delay (i.e., 3oe was equal to 50% of
the mean). The nominal propagation delay of the longest sensitizable path in c880 was 46.8
nanoseconds(ns). Based on this result, to give a reasonable safety margin for the design,
we chose a clock period of 55 ns. None of the 8,000 instances in Figure 2(a) had a delay
longer than this clock period. We then generated another 8,000 instances: 4,000 instances
assuming a 10% shift in the nominal delay at each signal and 4,000 instances with a 30%
shift at a small, randomly chosen, subset of signals to reflect the worst case process. In other
words, the mean of the propagation delay at each signal or at some signals in this second set
of 8,000 instances was chosen to be higher than the given nominal propagation delay. Curve
(b) in

Figure

2 shows the distribution of the delays of the longest sensitizable paths for such
generated instances of c880. The timing analyzer reported 601 instances having sensitizable
paths longer then 55 ns and thus, being delay-defective.
6050150250Propagation delay of the longest sensitizable path (ns)
Number
of
instances
(a)
(b)

Figure

2: Distribution of longest sensitizable path delays for 8,000 instances generated for
c880 when the value of the mean for each signal was (a) equal to the given nominal delay,
(b) higher than the nominal delay.
Next, we wanted to see how the delay test sequences generated under different sensitization
conditions (i.e., robust, non-robust, etc.) perform in detecting these delay-defective
instances. The nominal delay of the longest sensitizable path of c880 was 46.8 ns. For test
generation, we have only considered those paths whose nominal propagation delay was longer
than 38.8 ns. There were 2441 such paths: 2050 robust testable, 137 non-robust testable,
functional sensitizable and redundant. We prepared three sets of test sequences
for these selected path delay faults: (1) robust tests for all robustly testable paths,
(2) non-robust tests for all robustly and non-robustly testable paths and (3) robust test for
robustly testable paths plus non-robust tests for the non-robustly testable paths. As shown
in

Table

2, out of 2441 chosen long paths, 391 paths were robustly untestable and 254 paths
were non-robustly untestable.
Test set # of path delay faults # of vector # of delay-defective inst.
tested untestable pairs total detected
Robust 2050 391 2050 601 567
Non-Robust 2187 254 2187 601 527
Robust+Non-Robust 2187 254 2187 601 585

Table

2: Delay testing results for c880.
Then, we used a multiple-delay logic simulator that accepts externally supplied
gate/signal propagation delays to simulate these test sets. During simulation of a two-pattern
test for an instance, all signals under the first vector were stabilized before the
second vector was applied. The outputs were observed ns later and the observed values
were compared with the expected values to determine if a delay-defective instance was detected
by the test set. Table 2 shows the number of test vector pairs in each test set and the
number of detected instances (out of 601 delay-defective instances).
None of the applied test sets detected all delay-defective instances. Even the last test
set, which is the best set under the existing test strategy, missed a significant portion of
delay-defective instances. There are three reasons for this: (i) The non-robust tests for
the non-robustly testable paths may have been invalidated by defects on other paths. This
phenomenon can be observed by comparing the results of the "Robust" test set and the "Non-
Robust" test set since the later missed several delay-defective chips which were detected by
the "Robust" test set. This problem and a possible solution for it is one of the topics of
this research. (ii) Some of the 254 non-robustly untestable paths may have still affected the
circuit's performance. Timing defects on these paths were not targeted and, thus, might
have stayed undetected. These are the functional sensitizable paths and test generation for
them is, therefore, necessary. The test generation for functional sensitizable paths is another
topic of this paper. (iii) We have only considered long paths for test generation. Therefore,
a faulty short path may not have been detected. However, for this particular experiment,
very few instances were missed due to this reason.
3 Definitions
For a given path delay fault, the condition under which it is being tested (robust, non-
robust, functional sensitizable) depends on the applied input vector pair and on the transitions
it produces on the path's on- and off-inputs. A transition in which the value of
some input changes from the controlling to the non-controlling value is denoted cv!ncv and
similarly, we have a ncv!cv transition.
For some input vector pair depending on the transitions produced on the
on-input and its corresponding off-inputs, the off-inputs that might appear in the target
path can be divided into four categories: robust, non-robust, functional sensitizable and
functional unsensitizable off-inputs. The definitions of the various types of off-inputs are
given in Table 3.
off-input on-input transition
transition cv!ncv ncv!cv
cv!ncv robust non-robust
ncv!cv funct. unsensitizable funct. sensitizable
stable ncv robust robust
stable cv funct. unsensitizable funct. unsensitizable

Table

3: Classification of off-inputs.
Example 1 Let an AND gate with two inputs, a and b as shown in Figure 3, be part of our
target path P (input a is the on-input and input b is the off-input). In this paper, value S0
on some signal s denotes a stable 0 (1) value under V while values containing symbol
X denote unknown (unspecified) values. For example, if the value on signal s is X1 it means
that the value of s under vector v 1 is unknown and it is equal
a
a
(a) robust off-input
a
(b) non-robust off-input
a
(c) funct. sensitizable off-input

Figure

3: Different types of off-inputs for an AND gate.
In order to robustly propagate a rising transition (cv!ncv) through the AND gate

Figure

3(a)), the off-input b needs to stabilize on its non-controlling value after the second
input vector has been applied. This condition is satisfied either, if the off-input b has a
stable non-controlling value or if it has a rising transition. In these cases the off-input b is
said to be robust (R). A transition on a robust off-input can never mask the transition on its
corresponding on-input. If the off-input b, after the second input vector has been applied,
stabilizes on its controlling value, further propagation of the rising transition on the target
path is stopped. In this case the off-input b is said to be functional unsensitizable (FUS).
If we want to robustly propagate a falling transition (ncv!cv) through the AND gate,
we must have a stable non-controlling value on the off-input b (Figure 3(a)). In the case when
input b has a rising transition, the off-input is called non-robust (NR) off-input (Figure 3(b)).
The rising transition on b may mask the on-input's falling transition and in that case further
propagation of the transition on the target path is stopped. This happens when the transition
on b arrives later than the transition on a. On the other hand, if the off-input b has a falling
transition (Figure 3(c)), the fault effect on the target path can be observed only if the
transition on the off-input is also late. In this case, the circuit under test has a multiple path
delay fault. Such an off-input is said to be functional sensitizable (FS) off-input. In the case
when the off-input has a stable controlling value further propagation of the transition on the
target path is stopped and thus, the off-input is a functional unsensitizable off-input. 2
The types of off-inputs which appear in a given path when a test is applied, determine
the condition under which the path is being tested. For example, if in a given target path,
for a given input vector pair, all of the off-inputs are robust we say that the path is being
tested under the robust condition. If besides robust off-inputs there are also some non-robust
off-inputs but there are no functional sensitizable or functional unsensitizable off-inputs, the
path is being tested under the non-robust condition. A path is tested under a functional
sensitization condition if, for a given input vector pair, besides robust and nonrobust off-
inputs there are also some functional sensitizable off-inputs and there are no functional
unsensitizable off-inputs. A functional redundant path, under all possible input vector pairs,
has at least one functional unsensitizable off-input.
We have a good knowledge about robustly testable paths since they have been the target
of most delay testing research. A two pattern test non-robust test for a path
delay fault if and only if (1) it launches the required transition at the root of the path, (2)
under vector v 2 all of the path's off-inputs settle at non-controlling values and (3) there is at
least one off-input that has a cv!ncv transition when the on-input has a ncv!cv transition.
As discussed earlier, a non-robust test may become invalid if any non-robust off-input is late
and high quality test generation for these faults requires special caution.
The following definitions are needed because we use timing information to guide the test
generation process for non-robust tests with high robustness and for functional sensitizable
tests. Let be an input vector pair applied for delay testing of a given target
path and let v 2 be applied at time the logic values on the
signals in the circuit will become stable.
1 The time when the logic value on signal f becomes stable under v 2 is called
arrival time of f under v 2 . The arrival time at connection f under v 2 in the instance with
the nominal delays on the signals (fault free instance) is denoted with AT (f; v 2 ).
Definition 2 For a given off-input g and its corresponding on-input f , the difference
called slack of the off-input g.
Definition 3 If a given path, for a given vector pair, can be sensitized it is called true path
and if it cannot, it is said to be false.
A path which is false in the fault free instance might become true for some faulty in-
stances. We say that a path is functional sensitizable if, under vector v 2 (1) all of its off-inputs
settle to their non-controlling values when the corresponding on-input has a non-controlling
value and (2) at least one off-input in the entire path settles to a controlling value when the
corresponding on-input has a controlling value. For a given instance, an FS path will be a
false path if for all possible input vector pairs that functionally sensitize the given FS path
the arrival time of any of its FS off-inputs is earlier than the arrival time of the corresponding
on-input. However, if the arrival times of FS off-inputs are late, the FS path might become
a true path and determine the circuit's timing behavior.
Example 2 Consider the circuit given in Figure 4. In this circuit the only robustly and
a
c
d
e
f

Figure

4: Functional sensitizable path.
non-robustly untestable path delay faults are fadgh, risingg, fbceh,risingg, fafh, fallingg
and fbfh, fallingg. The first two delay faults are functionally redundant and according to
what was said earlier, they can never determine the circuit's performance and do not need
to be tested. The last two are functional sensitizable faults. The vector pair shown in the
figure functionally sensitizes both paths. Suppose our target fault is fafh, fallingg. We say
that path fbfh, fallingg is associated with the target path. The necessary condition to detect
a fault on the target path is that the functional sensitizable off-input b is also late. In other
words, the fault effect on a functional sensitizable target path can only be observed in the
presence of multiple delay faults [9]. 2
Since the detection of a fault on an FS path is a function of the delays on some of the
signals in the rest of the circuit, for the same target path, different FS tests have a different
probability of detecting the defect. We are interested in generating an FS test which has the
highest probability of detecting a fault on the target FS path.
In the following section we give an outline of our test generation methodology for high
quality non-robust test. We introduce robustness as our metric for guiding the test derivation
process and we also present an algorithm for generating validatable non-robust tests.
4 Generation of High Quality Non-Robust Tests
A non-robustly testable path under any test vector pair has at least one non-robust off-
input while the rest are robust off-inputs (Table 3). The number of non-robust off-inputs for
a given target path can be different for different non-robust tests. Since we are interested
in generating non-robust tests that are more robust, one of our objectives is to find a test
with minimal number of non-robust off-inputs for a given target path. Also, two non-robust
tests with the same number of non-robust off-inputs can have different quality with respect
to their effectiveness in detecting defects.
denote the non-robust off-inputs under a given vector pair
denote the slacks of those non-robust off-inputs. Then the slack of
the non-robust test V is defined as min
g.
Among all non-robust tests for a given path, our goal is to find a non-robust test V that
has the maximum slack. The reason for this is the following: if the slack at the non-robust
off-inputs is larger, the probability that the non-robust off-input transition masks the on-
input transition is lower. A non-robust test with a larger slack can tolerate larger timing
variations at the non-robust off-inputs. For delay defects caused by process variation, the
slack of a non-robust test should be closely related to the probability of fault masking at
the non-robust off-inputs. Figure 5(a) shows a path delay fault that is robustly untestable
but non-robustly testable and Fig. 5(b) and Fig. 5(c) show two different non-robust tests for
the same path. The test given in Fig. 5(c) can tolerate a 12 ns variation while the test in
Fig. 5(b) can tolerate only a 2 ns variation.
The robustness of a non-robust test is defined as its slack. The higher the robustness,
the lower the probability of the test being invalidated. The robustness ranges from \Gamma1 to
1. The robustness of a robust test is defined as 1, while robustness of a vector pair which
is neither a robust nor a non-robust test is defined as \Gamma1.
5ns
20ns
(a)
16ns 17ns
18ns
7ns
6ns
5ns
20ns
(b)
8ns
5ns
20ns
6ns
7ns
(c)

Figure

5: Different non-robust tests can tolerate different timing variations.
4.1 Algorithm for generating non-robust tests with high robust-
ness
A brief summary of our algorithm is given in Figure 8. In the following, we explain the
details of the algorithm and give a step-by-step example.
Step 1: To non-robustly test a path delay fault, all of the off-inputs must have a non-controlling
value under vector v 2 and a transition must be created at the source of the path
under test V . These requirements have to be satisfied by any test vector and they are called
mandatory assignments [11]. Hence, in the first step we find all mandatory assignments and
their implications [14].
We then compute the earliest arrival time of each signal restricted to these mandatory
assignments. Notice that given a Set of Mandatory Assignments (SMA), certain input vector
pairs may produce values that violate the given assignments at some signals. The earliest
arrival time at signal f under a given SMA is defined as the earliest arrival time at f among
all vector pairs not violating the SMA.
Example 3 Consider the circuit given in Figure 6. The target path is shown in bold face.
20ns
5ns
8ns
21ns
a
e
c
f
d
5ns
0ns
6ns
1ns
0ns
7ns
2ns
8ns
0ns
1ns
0ns

Figure

Computing the SMA and the earliest arrival times.
The arrival times and the transitions for the signals on the target path are as shown. Signals
are primary inputs and the transitions on them are assumed to arrive at time
In this example all the gates are assumed to have a unit delay for both, the rising and
the falling transition. After assigning non-controlling values under the second vector v 2 to
all off-inputs and after implying these values, the obtained set of mandatory assignments is
as shown. Next, the earliest arrival time for each signal under the given SMA is computed.
These values are shown under the circuit. With s(f) and s(r) we denote the arrival times of
the falling and rising transitions on signal s, respectively. For example, the notation
6ns means that the earliest arrival time for a falling transition on signal d under the given
SMA is 6ns. 2
Definition 5 For a non-robustly testable path, the off-inputs whose corresponding on-input
has a ncv!cv value are called NR candidate off-inputs.
Step 2: We identify all NR candidate off-inputs for the target path and we attempt to
convert them (one at a time) into robust off-inputs by assigning a stable non-controlling
value to them. The order of processing of the NR candidate off-inputs is determined in
the following way: for each candidate, we compute the slack of the NR candidate off-input
(i.e., the difference between the arrival time of the corresponding on-input and the earliest
arrival time of the transition on the NR candidate off-input). We first try to convert the NR
candidate off-input whose slack is the smallest. We do that because a non-robust off-input
with a smaller slack has a higher probability of masking its on-input transition than the NR
off-input with a larger value of slack.
Example 4 Consider again the circuit on Figure 6. The NR candidate off-inputs are signals
f , i and k. Their slacks are 12ns and 20ns. Since the
NR candidate off-input f has the smallest slack we first try to convert signal f into a robust
off-input by assigning it a stable 0 value. Neither the assignment of S0 value to f nor the
20ns
5ns
8ns
21ns
a
e
c
f
d
3ns
1ns
2ns
0ns
5ns
6ns

Figure

7: Converting non-robust off-inputs into robust off-inputs.
implications of this assignment cause any conflicts and signal f is successfully converted into
a robust off-input. Next, the earliest arrival times at signals are updated incrementally since
for certain signals they may change due to the augmented set of mandatory assignments. In
our example, the earliest arrival time of signal g is removed from the set since g has a stable
value under the new SMA and the earliest arrival time of signal i becomes 3ns. The
slacks of the NR candidate off-inputs can now be found to be: 17ns and slack(k)
20ns. Therefore, the off-input i is selected as next signal for processing. However, under
the given SMA it is not possible to assign a stable non-controlling value at signal i and
we continue by processing signal k. Off-input k can be converted to a robust off-input by
assigning a stable 0 value to primary input j. The new SMA and the earliest arrival times
are shown in Figure 7. 2
For each non-robustly testable path repeat:
1. Assign desired transitions at on-inputs.
2. Convert NR candaidate off-inputs into robust off-inputs(if possible), one
at a time. Leave the values of the candidate off-inputs which could not
be converted into robust off-inputs unassigned. Timing information is
used to determine the order of the candidates.
3. Convert the rest of the unassigned off-inputs into NR off-inputs one at
a time and do backward justification. Timing information is used to
determine the order of processing of the candidates and to make decisions
during justification process.
4. Assign values to the remaining primary inputs that still have their values
unassigned.

Figure

8: Summary of the algorithm for generating NR tests with high robustness.
Step 3: For the NR candidate off-inputs which cannot be converted into robust off-inputs,
assigning non-robust transitions cannot be avoided under the current, partially assigned
vector pair T. To minimize the probability that the on-input transition is masked by the
transition at a non-robust off-input g, we try to find a test for which the arrival time of the
transition at signal g is the earliest possible. To achieve this, we use the calculated earliest
arrival times to guide the justification process. To justify a transition at the output of a
gate, we choose an input (among all inputs which could have a transition under current
partial test) with the earliest arrival time and assign a transition at this input and stable
non-controlling values at all other inputs. This backward justification process continues until
the primary inputs are reached or a conflict has occurred. In the latter case, we backtrack
to the last decision point and justify the transition at the input with the next earliest arrival
time. This justification and backtracking processes are very similar to those used in a typical
test generation algorithm.
In this test generation process, we gradually assign values at internal signals and primary
inputs. Therefore, those NR candidate off-inputs which are processed later will have a smaller
search space than those that were processed first. That is why we process the most critical
NR candidate off-inputs (the ones with the smallest slack) first.
Example 5 In the circuit in Figure 7 signal i is a NR off-input. We want to make sure that
the falling transition on signal i arrives as early as possible. Since the value at signal h has
to be justified using the calculated earliest arrival times for signals d and e we can decide
that the transition on signal i will be the earliest if we assign a falling transition to signal e
and stable 1 to signal d (Figure 9). 2
Step 4: At the end, to obtain a completely specified test for logic simulation in our experiment
and to minimize the number of sensitized paths associated with the NR off-inputs, we check
if there are some primary inputs that do not have values assigned and we assign them so
that the number of transitions at the primary inputs is minimized. In this work we do
not consider test compaction. If test compaction is used this step of the algorithm can be
omitted.
20ns
5ns
8ns
21ns
a
e
c
f
d

Figure

9: Backward justification and assigning unspecified values at PIs.
Example 6 The only primary input that does not have values completely specified is c and
in this step we assign it a stable 1. The final values on all the signals are shown in Fig. 9. 2
4.2 Generating validatable non-robust tests
To obtain a high quality test for a non-robustly testable fault, the first attempt should be
to generate a validatable non-robust test since a VNR test is guaranteed to detect a delay
defect on the target path independent of the delays on the signals in the rest of the circuit.
Example 7 Consider the circuit given in Figure 10(a). Path fbcef , risingg is robustly
a
d
e
f
(a)
(b)
a
d
e
f

Figure

10: A validatable non-robust test for path fbcef , risingg.
untestable but non-robustly testable. The test T is a non-robust test for path
risingg. If the partial path fbd, risingg is faulty (and, thus, path fbdf , risingg is
faulty), it will invalidate the test T 1 . Test shown in Figure 10(b) is a robust
test for path fbdf , risingg. If the circuit passes both tests, we can conclude that the path
, risingg is fault-free. Therefore, these two tests form a validatable non-robust test for
the fault fbcef , risingg. 2
There may exist many validatable non-robust tests for a given fault. We are interested
in finding the set with minimal cardinality. Our algorithm for generating such a set of two
pattern tests consists of several steps.
Step 1: For each non-robustly testable fault, we first convert NR candidate off-inputs into
robust off-inputs and we obtain a non-robust test T 0 with a minimal number of non-robust
off-inputs. This is done using the procedure described in the previous subsection, i.e., we
start with a minimally specified non-robust test and we convert the NR candidate off-inputs
into robust off-inputs one at a time. If this conversion causes conflict we recover the previous
value at that off-input (i.e., X0 or X1). We then proceed to the next NR candidate off-input
and repeat the process.
Step 2: The partial test obtained after processing all NR candidate off-inputs we call a semi-
robust test. The semi-robust test has don't cares at some primary inputs and we specify these
don't cares in such a way that the number of transitions at the primary inputs is minimized
(i.e., a X1 is specified as 11, X0 is specified as 00, and XX as 00 or 11). We denote the final
non-robust test as T . The implications of T are then performed.
Step 3: Next, we examine the non-robust off-inputs and identify the paths that need to be
robustly tested to validate T .
Example 8 Suppose that the target path is fh
where h 1 is a primary
input and h n is a primary output, and f i denotes the on-input feeding gate h i+1 (Figure 11).
Suppose g i is a non-robust off-input and its corresponding on-input is f i under NR test T .

Figure

11: Validating a non-robust test.
We denote the partial path from g i to h n as p i . Because T is a non-robust test and g i is
a non-robust off-input, T must sensitize one or more partial paths from primary inputs to
. We denote these partial paths as q i 1
the arrival time of the transition
on g i is determined by the propagation delays of these paths. If we can robustly test the
concatenated paths q i 1
and if the circuit passes these tests, it can be
guaranteed that under T the transition at g i
will not be late. For each non-robust off-input
i , we identify the set of paths, G i that needs to be robustly tested to validate T . If all of
the paths in G i
are robustly testable, test T along with the robust tests paths in G i
forms a
validatable non-robust test for the target path. 2
In developing test T , we minimize the number of transitions at primary inputs. Therefore,
typically only a very small number of partial paths that end at a non-robust off-input is
sensitized. Thus, only a small number of off-paths needs to be examined. This not only
reduces the computational complexity but it also reduces the cardinality of the validatable
non-robust test.
There is a possible extension of this algorithm for identifying more VNR testable paths.
The condition for robustly testing the sensitized partial paths (from primary inputs to non-robust
off-inputs), can be relaxed so that they are tested under the VNR condition. However,
if we adopt this extension, the following situation may occur: in generating a VNR test for
path A, the VNR testability of path B is required and in generating a VNR test for path B,
the VNR testability of path A is required. In this case, neither of the paths is VNR testable.
In our prototype program we did not implement this extension.
Our experimental results, presented in section 6, show that using the timing information
in the process of non-robust test generation substantially improves the quality of a non-robust
test. Moreover, the results have indicated that testing functional sensitizable paths could
lead to further improvement of the quality of delay tests. In the following section we describe
our test generation method for FS paths. We first give an outline of our methodology to
emphasize our objectives, and then we present the details of the implementation.
5 Test Generation for Functional Sensitizable Path
Delay Faults
As stated earlier, a fault on a functional sensitizable path can, under some faulty condi-
tions, degrade the circuit's performance and therefore, FS paths should be tested. A given
FS path can have a number of different FS tests. If we want to select a small number of
input vector pairs to test a functional sensitizable path (in this work we select only one),
we should select those tests that have a higher probability of making the defects on the FS
path observable.
The necessary condition to detect a defective functional sensitizable path is that all of
the paths associated with its functional sensitizable off-inputs (association has been defined
in section 3, Example 2) are also defective. Hence, in general, the larger the number of FS
off-inputs, the smaller the probability of detecting a defect. The number of the functional
sensitizable off-inputs in a given path depends on the applied test vector pair. Therefore, one
of the objectives of our test generation algorithm is to minimize the number of FS off-inputs.
Reduction of the number of FS off-inputs can be achieved by maximizing the number of
off-inputs that are robust or non-robust. Still, just minimizing the number of FS off-inputs
would not be a sufficient guarantee for detecting the fault on an FS path. For example, an
FS path can have the same number of FS off-inputs under two different FS tests but still, one
of the two tests might have a higher probability of detecting a fault. The tests that have a
higher probability of detecting a fault are those under which the FS off-inputs have a smaller
slack (i.e., the nominal arrival times of the FS off-inputs should be as late as possible). This
means that in order to find an FS test which has a high probability of detecting multiple
path delay faults, we need to include available timing information into the process of test
generation.
denote the FS off-inputs under a given vector pair V , and
denote the slacks of those FS off-inputs. Then the slack of the FS test V is
defined as max
g.
Contrary to the algorithm for generating non-robust tests, presented in the previous
section, in the process of generating FS tests we attempt to find tests whose value of the
slack is minimal. The slack in this case can be positive or negative. We look for a test with
the most negative slack, if exists. Otherwise, we look for one with the least positive slack.
Such tests can tolerate only small timing variations on their FS off-inputs and are more likely
to lead to the detection of a faulty FS path.
Suppose that under some test T all paths associated with FS off-inputs are robustly
testable. If we apply robust tests to cover those associated paths and the circuit passes
these tests, we can conclude that the transition at the FS off-input under T will not be late.
Therefore, T will not be able to detect defects on the target FS path and it does not need
to be applied [8, 12].
(b)

Figure

12: Example of an FS test that cannot detect a faulty FS path.
Example 9 Consider the circuit given in Figure 12(a). Test
associated with the FS off-input g (Figure 12(b)). Test robustly tests path
. If we apply T 2 and the circuit passes the test, we can conclude that the arrival time of
the signal at FS off-input g in P 1 under test T 1 will not be late. Thus, T 1 will not be able to
detect a defect in P 1 . Therefore, we do not need to include T 1 in the test set for P 1 . 2
5.1 Algorithm for generating functional sensitizable tests
To generate FS tests we need to identify the functional sensitizable paths. We perform
this by eliminating functional redundant paths from the set of non-robustly untestable paths,
using the algorithm and tool described in [3]. However, the algorithm in [3] uses only second-
vector analysis and the identified set of FS paths might be pessimistic (too large). We use
the algorithm from [3] since it is is very fast and can be applied to large designs. The test
generation algorithm for an FS path delay fault is summarized in Figure 13.
Step 1: Functional sensitizable paths besides robust and non-robust off-inputs have at least
one FS off-input. In the process of generating NR tests the off-inputs whose corresponding
on-input has a ncv!cv transition were called candidate off-inputs. In the context of
generating tests for FS paths, here we redefine such off-inputs.
Definition 7 The off-inputs whose corresponding on-input has a ncv!cv transition are
called FS candidate off-inputs.
Step 2: During test generation FS candidate off-inputs can, depending on the transition assigned
to it, become either robust, non-robust or functional sensitizable off-inputs (Table 3).
Our goal is to minimize the number of FS off-inputs. Thus, we attempt to generate a test
under which the highest number of FS candidate off-inputs is either robust or non-robust.
Because the transition on a non-robust off-input can mask the transition on the corresponding
on-input while this can never happen in the case of a robust off-input, it is preferred that
we achieve the above goal with as large number of robust off-inputs as possible. Hence, in
our algorithm we process the FS off-input candidates one at a time and to each candidate we
first attempt to assign a stable non-controlling value (i.e., we try to convert it into a robust
off-input). Similar to the algorithm for non-robust paths, we use the forward implication
and backward justification process to check if the desired transition can be assigned. If the
attempt to convert some FS candidate off-input into robust off-input fails, we leave its value
unspecified and proceed with the next candidate in the list.
Step 3: After all FS off-input candidates have been processed we start over with the ones
that have their transitions left unspecified and we attempt to convert them into non-robust
off-inputs by assigning a cv!ncv transition to them.
Step 4: If the attempt to convert some FS candidate off-input into non-robust off-input fails,
we assign a ncv!cv transition to the FS candidate off-input (i.e., we convert it into an FS
off-input).
As it was pointed out in the outline of our methodology, the order in which we process the
FS candidate off-inputs is very important for generating a good quality FS test. Therefore,
we use the partial timing information available under the set of mandatory assignments
and their implications to calculate the earliest arrival time of the transition on each of the
FS candidate off-inputs. This information is then used for calculating the slack of each
candidate. The order in which we process the candidates is determined by their slacks.
We process the candidates with the larger slack first since they are less likely to allow the
propagation of the defect to the primary output and to make it observable. Therefore, it is
desired for them not to be converted into FS off-inputs. On the other hand, the FS candidate
off-inputs that have a smaller slack have a higher chance of sensitizing the given FS path
under faulty conditions.
For each functional sensitizable path repeat:
1. Assign desired transitions at on-inputs.
2. Convert FS candidate off-inputs into robust off-inputs (if possible), one at
a time. Leave the values of the candidate off-inputs which could not be
converted into robust off-inputs unassigned. Timing information is used to
determine the order of processing of the candidates.
3. Convert unassigned off-inputs into non-robust off-inputs (if possible), one at
a time. Timing information is used to determine the order of processing of
the candidates.
4. Convert the rest of unassigned off-inputs to FS off-inputs.
5. Do backward justification. Timing information is used to make decisions
during justification process.
6. Assign values to the remaining primary inputs that still have their values
unassigned.
7. Check whether or not all paths associated with FS off-input are robustly
tested.

Figure

13: Summary of the algorithm for generating FS tests.
A possible problem in ordering the candidates could arise in the case when some of the
off-inputs in the given FS path have non-robust transitions assigned to them. In that case
the requirement to find a test that can at the same time tolerate large timing variations at
NR off-inputs and small timing variations at FS off-inputs, is a hard task, since the fanin
cones of NR and FS off-inputs may intersect. Fortunately, our results have shown that in the
large majority of FS paths our procedure does not create non-robust off-inputs. Under most
of the generated FS tests, there are only robust and FS off-inputs present. Each time after
some FS candidate off-input has successfully been assigned a transition we update the set of
mandatory assignments and their implications and recompute the slacks of the FS off-input
candidates.
Step 5: After the appropriate transitions have been assigned to all FS candidate off-inputs,
the final justification process is done in a way which maximizes the chance that the non-robust
off-input arrives as early as possible while the FS off-input arrives as late as possible.
If the target path has both, non-robust and FS off-inputs, and if the fanin cones of some non-robust
and FS off-inputs intersect, the justification process is done so that the non-robust
off-input arrives as early as possible.
To select a test under which the probability of the FS off-input arriving as late as possible
is the highest, we sort the fanins to a gate whose output needs to be justified in a decreasing
order with respect to the computed earliest arrival times (latest arriving signal is the first
in the list). If the transition which we need to justify is cv!ncv we attempt to assign the
same transition to all of the fanins that could have a transition under the current, partially
assigned vector pair, processing them as they appear in the fanin list. If the transition we
need to justify is ncv!cv, we try to assign that transition to the fanin with the latest arrival
time among all the fanins that could have a transition and a stable non-controlling value to
the rest of the inputs. If during justification process a conflict is detected we backtrack to
the last decision point and attempt the justification with the next fanin in the list. In order
to achieve that the non-robust off-input arrives as early as possible we use a similar strategy
but we order the fanins so that the earliest arriving signal is first in the list.
Step After the justification process is done, if there are some primary inputs that still
have unassigned values, we assign them so that the number of transitions on the primary
inputs is minimized.
Step 7: Finally, we check if the paths associated with the FS off-inputs were targeted by a
robust test, since if they were, the robust test set would detect the defect that causes the
late arrival time at the FS off-inputs. Therefore, such an FS test does not need to be applied
(i.e., it cannot detect a faulty FS path).
6 Experimental Results
We have implemented the previously-described algorithms for generating (1) validatable
non-robust tests, (2) non-robust tests with high robustness and (3) functional sensitizable
tests. We use the experimental setup described in Section 2 to evaluate the quality of the
generated test sets.
For each circuit under test we test a number of long functional irredundant paths. Table 4
summarizes the information about selected paths for a 2 bit adder, two ISCAS85 benchmark
circuits and an MCNC benchmark finite state machine styr. Column 2 shows the delay of
the longest sensitizable path [2] in the fault free instance. For the 2 bit adder we select all
functional irredundant paths while for the rest of the tested circuits we select a subset of
all paths according to the specified cut-off time (column 3). The clock period (column
is chosen using the information about the delay of the longest sensitizable path. The last
four columns show the number of selected functional irredundant paths and the number of
robust (R), non-robustly testable (NR) and functional sensitizable (FS) path delay faults
in the tested circuits. As it can be seen, in c880 a very large portion of the longest paths
is robustly testable while in the case of c432, most of the longest paths are functional
sensitizable paths and there are no long robustly testable paths.
longest cut-off clock number of R NR FS
Circuit delay time period irredundant paths paths paths
(ns) (ns) (ns) paths selected
styr 42.80 30.00 47.00 210 145 36 29
a The test generation was done for 2117 paths

Table

4: Path selection.

Table

5 shows the test generation results for validatable non-robust tests. The second
column shows the number of validatable non-robust paths among the non-robustly testable
paths for each tested circuit. The last column shows the number of vector pairs required for
testing those VNR faults, i.e., the number of paths associated with NR off-inputs that need
to be robustly tested plus one. For example, for c880 we identify 111 out of 137 NR testable
faults as VNR testable. Each of those 111 VNR testable faults requires that exactly one
other path is robustly testable in order to validate the corresponding NR test. Therefore,
for each of those 111 faults, the validatable non-robust test set consists of exactly two input
vector pairs. None of the paths we consider for c432 is VNR testable.
number of VNR ave. num. of vector
Circuit testable paths pairs per path
styr 22 2.0

Table

5: Test generation results for validatable non-robust tests.
For each NR testable path, we attempt to generate a NR test with a large slack. Table 6
shows the results for NR test generation. The second column gives the number of NR
testable faults. The third column shows the average slack of the NR tests generated using
our test generation algorithm. For comparison, we generate two other sets of NR tests.
One is obtained by simply generating a NR test (all off-inputs are set to a non-controlling
value under vector v 2 while the values on the off-inputs under vector v 1 are obtained after
specifying the values on primary inputs) for each path and after a two-pattern NR test is
generated we randomly fill in the unspecified signal values with 0's and 1's. For the other NR
test instead of randomly filling in the unspecified values we fill them such that the number of
transitions at the primary inputs (and at the internal signals) for the NR test is maximized
for each target path. We measure the slack of each NR test in all three non-robust test
sets and the results are shown in the last three columns of Table 6. For the 2 bit adder
the average slack for randomly filled in NR test is negative. This result implies that for
the fault-free instance, the desired transition cannot be created at the output because the
non-robust off-inputs have transitions arriving later than the on-input transitions and will
mask them. For all tested circuits our test generator drastically increases the average slacks
and, thus, our test set will allow larger timing variations at the non-robust off-inputs.
As discussed in section 5, in our algorithm for generating tests for functional sensitizable
faults, we try to maximize the chance of detecting a defect in the FS target path by generating
test sets with as small number of FS off-inputs as possible. The results in Table 7 show that
we achieve that goal for most of the tested circuits. The third column shows the average
number of FS candidate off-inputs per path for each of the tested circuits. Circuit c432 has
number of NR Average slack (ns)
Circuit testable paths ours random max.transitions
styr 36 12.85 5.63 1.39

Table

non-robust tests.
the highest number of FS candidate off-inputs (23) which complies with the fact that c432
has a very high percentage of functional sensitizable paths (97% of the selected irredundant
paths). As the results in the last three columns show, in most circuits, for a large number
of FS paths, all but one FS candidate off-input were made robust (c432 is the only circuit
in which the number of FS off-inputs was considerably higher than one). Also, most of our
FS tests did not create any non-robust off-inputs (column 5).
num. of ave.num. of FS candidate converted converted converted
Circuit FS paths off-inputs per path into R into NR into FS

Table

7: Test generation for functional sensitizable paths.
For each circuit, we prepare the following 7 test sets for testing the selected long irredundant
paths:
Test set 1: robust tests for all robustly testable paths (R),
Test set 2: non-robust tests for robustly and non-robustly testable paths, with randomly
filled in don't cares (randNR),
Test set 3: test set 1 plus non-robust tests with randomly filled in don't cares for the
non-robustly testable paths (R+randNR),
Test set 4: test set 1 plus non-robust tests with don't cares filled in so that the number
of transitions at the primary inputs is maximized for the non-robustly restable paths
(R+worstNR),
Test set 5: test set 1 plus non-robust tests with high robustness for the non-robustly restable
paths (R+bestNR),
Test set test set 1 plus validatable non-robust tests for non-robust paths that have
such tests and non-robust tests with high robustness for the remaining non-robustly testable
paths (R+VNR+bestNR),
Test set 7: test set 5 plus FS tests for functional sensitizable paths (R+VNR+bestNR+FS).
We generate a large number of instances for each circuit. In order to generate instances
that can be considered as good representatives for different chips in the manufacturing line,
we use several strategies. In one of them, we generate 4000 instances for each of the tested
circuits by assuming that the propagation delays on all signals are random variables with
normal distribution of a given mean and standard deviation. We choose the mean to be
1.1 times the nominal propagation delay and the standard deviation to be 1/6 of the mean
value. For some circuits (2 bit adder and styr) this strategy did not give a very good sample
of faulty instances since in many of generated faulty instances the same set of paths was
responsible for the defect. Therefore, we generate additional 4000 instances assuming that
the propagation delays on some, randomly chosen signals are random variables with normal
distribution of a given mean and standard deviation. We prespecify that a 30% of all gates
and 50% of their fanins will have propagation delays different than nominal, and we choose
a mean which is 30% above the nominal and a standard deviation as 1/6 of the mean value
for those specified signals. In this case we achieve that a larger set of different path delay
faults is responsible for the degradation of the circuit's performance.
We use the timing analyzer [2] to identify the delay of the longest sensitizable path in
each generated instance. Instances for which this delay is longer than the clock period are
considered delay-defective. We simulate the above 7 test sets for each delay-defective instance
to examine whether the faulty instance can be detected or not. Table 8 shows the obtained
results. The number of defective instances according to the timing analyzer for each of the
tested circuits is given in the second column. The remaining columns show the number
of detected defective instances for each of the seven applied test sets. As it can be seen,
the number of undetected delay-defective instances decreases as the test set expands and
includes, beside robust tests, tests for NR, VNR and FS paths. For example, in the case of
styr the number of detected delay-defective instances with the robust test was 1811 (column
and it has increased to 3052 when VNR and high quality non-robust tests were added for
the non-robustly testable paths (column 8). The NR test set with don't cares filled in such
that the number of transitions is maximized detects 20 less instances (3032 vs. 3052) than
Test set 6. Similar happens for the NR test with randomly filled in don't cares. Only when
Test set 7 (which includes FS tests) is applied, the remaining delay-defective instances were
detected. For c880 92% of all tested paths were robustly and non-robustly testable and the
Test set 7 uncovers all but one defective instance. Even though for c880 the FS test when
applied alone detects 82 faulty instances all those instances were also detected by the Test
set 6. In the case of c432 the average number of FS off-inputs per path was 2.90 (Table 7)
and the probability of detecting a defective FS path in this circuit was small as our results
confirm.
num. of Set 1 Set 2 Set 3 Set 4 Set 5 set 6 Set 7
Circuit defective R NR R+ R+ R+ R+VNR+ R+VNR+
instances randNR worstNR bestNR bestNR bestNR+FS
styr 3058 1811 3032 3032 3032 3043 3052 3058
b The number of generated instances was 12000

Table

8: Number of detected faulty instances for different test sets.
In the case of the 2 bit adder we have selected all irredundant paths and our analysis has
shown that the longest FS path in this circuit was much shorter than the longest robustly or
non-robustly testable path. That is why our strategies for generating instances, in the case
of the 2 bit adder, could not create faulty instances in which an FS path would be longer
than the clock period. In this case, in order to maximize the chance of creating instances
with faulty FS paths, we generated additional 4000 instances by prespecifying some signals
along several paths to have random delays different than nominal. The above observation
led us to a conclusion, also pointed out in [15], that a 100% robust testability might not
be necessary for complete path delay testing. Instead, it might be enough to synthesize the
circuit so that only the longest paths are either robustly testable or redundant.
Conclusions
Our results show that test sets generated under existing testability criteria cannot detect
some of the timing defects. A defect on a non-robust target path will not be detected if any
of the paths associated with a NR off-input is defective. We show that among all possible
NR tests for a non-robustly testable path some NR tests are better than others in detecting
delay defects. A good NR test can tolerate larger timing variations and its probability of
being invalidated is smaller. We presented an algorithm that uses timing information to
generate non-robust tests with high robustness. A validatable non-robust test, like a robust
test, can guarantee detection of a path delay fault. In this paper, we also describe a method
for generating VNR tests.
Generating test sets for robust and non-robust path delay faults is not sufficient to cover
all possible delay defects. The reason for this is that some of the robustly and non-robustly
untestable path delay faults can, under some faulty conditions, be responsible for the circuit's
performance degradation. Those paths are functional sensitizable paths. An FS path is false
whenever any of the paths associated with its FS off-inputs is fault free. The defects on
functional sensitizable paths can be detected only if multiple delay faults exist. Therefore, a
special consideration has to be given to the test generation for FS paths. In this paper, for
the first time, an algorithm for generating FS tests has been developed. It is based on using
the timing information to guide the test generation towards obtaining good quality FS tests.
Our experimental results have demonstrated that using non-robust tests with high ro-
bustness, together with VNR and FS tests helps in detecting defects that would otherwise
stay undiscovered.



--R

Design for Testability for Path Delay Faults in Sequential Circuits.
Path Sensitization in Critical Path Problem.
Delay Testing For Non-Robust Untestable Circuits
Necessary and Sufficient Conditions for Robust Delay Fault Testability of Combinational Logic Circuits.
Synthesis of Robust Delay-Fault Testable Circuits: The- ory
DYNAMITE: An Efficient Automatic Test Pattern Generation System for Path Delay Faults.
Synthesis of Multi-Level Combinational Circuits for Complete Robust Path Delay Fault Testability

Synthesis of Delay-Verifiable Combinational Circuits
A Topological Search Algorithm For ATPG.
Delay Test: The Next Frontier for LSSD Test Systems.
Generation of High Quality Tests for Functional Sensitizable Paths.
Design of Robustly Testable Combinational Logic Circuits.
Recursive Learning: A New Implication Technique for Efficient Solutions to CAD Problems - Test
Delay Fault Coverage
An Experimental Delay Test Generator for LSI Logic.
On Delay Fault Testing in Logic Circuits.
A Test Generation System for Path Delay Faults.
On The Design of Path Delay Fault Testable Combinational Circuits.
An Automatic Test Pattern Generator for the Detection of Path Delay Faults.
Synthesis of Delay Fault Testable Combinational Logic.
Model for Delay Faults Based upon Paths.
Fast Identification of Robust Dependent Path Delay Faults.
The Error Latency of Delay Faults in Combinational and Sequential Circuits.
Transition Fault Simula- tion
--TR

--CTR
Yi-Min Jiang , Kwang-Ting Cheng, Analysis of performance impact caused by power supply noise in deep submicron devices, Proceedings of the 36th ACM/IEEE conference on Design automation, p.760-765, June 21-25, 1999, New Orleans, Louisiana, United States
Saravanan Padmanaban , Spyros Tragoudas, Non-Enumerative Path Delay Fault Diagnosis, Proceedings of the conference on Design, Automation and Test in Europe, p.10322, March 03-07,
Jing-Jia Liou , Angela Krstic , Kwang-Ting Cheng , Deb Aditya Mukherjee , Sandip Kundu, Performance sensitivity analysis using statistical method and its applications to delay, Proceedings of the 2000 conference on Asia South Pacific design automation, p.587-592, January 2000, Yokohama, Japan
S. Tragoudas , N. Denny, Path delay fault testing using test points, ACM Transactions on Design Automation of Electronic Systems (TODAES), v.8 n.1, p.1-10, January
Joonhwan Yi , John P. Hayes, The coupling model for function and delay faults, Journal of Electronic Testing: Theory and Applications, v.21 n.6, p.631-649, December 2005
Marwan A. Gharaybeh , Michael L. Bushnell , Vishwani D. Agrawal, Classification and Test Generation for Path-Delay FaultsUsing Single Struck-at Fault Tests, Journal of Electronic Testing: Theory and Applications, v.11 n.1, p.55-67, Aug. 1997
Andrzej Krasniewski, Evaluation of delay fault testability of LUTs for the enhancement of application-dependent testing of FPGAs, Journal of Systems Architecture: the EUROMICRO Journal, v.49 n.4-6, p.283-296, September
Pankaj Pant , Abhijit Chatterjee, Efficient diagnosis of path delay faults in digital logic circuits, Proceedings of the 1999 IEEE/ACM international conference on Computer-aided design, p.471-476, November 07-11, 1999, San Jose, California, United States
Angela Krsti , Kwang-Ting Cheng, Resynthesis of Combinational Circuits for Path Count Reduction and for Path Delay Fault Testability, Journal of Electronic Testing: Theory and Applications, v.11 n.1, p.43-54, Aug. 1997
