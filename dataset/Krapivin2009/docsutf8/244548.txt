--T
Register-transfer level estimation techniques for switching activity and power consumption.
--A
We present techniques for estimating switching activity and power consumption in register-transfer level (RTL) circuits. Previous work on this topic has ignored the presence of glitching activity at various data path and control signals, which can lead to significant underestimation of switching activity. For data path blocks that operate on word-level data, we construct piecewise linear models that capture the variation of output glitching activity and power consumption with various word-level parameters like mean, standard deviation, spatial and temporal correlations, and glitching activity at the block's inputs. For RTL blocks that operate on data that need not have an associated word-level value, we present accurate bit-level modeling techniques for glitching activity as well as power consumption. This allows us to perform accurate power estimation for control-flow intensive circuits, where most of the power consumed is dissipated in non-arithmetic components like multiplexers, registers, vector logic operators, etc. Since the final implementation of the controller is not available during high-level design iterations, we develop techniques that estimate glitching activity at control signals using control expressions and partial delay information. Experiments on example RTL designs resulted in power estimates that were within 7% of those produced by an inhouse power analysis tool on the final gate-level implementation.
--B
Introduction
Techniquesfor evaluatinga design for various metrics like area,
delay, and power consumption at all levels of the design hierarchy
are an important part of the design process. While it is typically
the case that lower-level estimation tools offer higher estimation
accuracy, their use to explore architectural tradeoffs during higher-level
design tends to be prohibitively time-consuming. Several
efficient techniques for estimating area and delay during high-level
design have been proposed [1, 2, 3, 4]. In this paper, we
focus on the problem of estimating power consumption from RTL
descriptions.
Designs at the architecture or RT level are characterized by the
instantiation of pre-designed macro blocks including arithmetic
operators, multiplexers, registers, vector logic operators, etc. In
order to avoid the increase in computational complexity introduced
by expanding these blocks to lower-level descriptions, it is
necessary to develop power models for these library blocks. The
development of such "black-box" models is an important part of
high-level power estimation, and is typically a one-time cost incurred
during library development. Another important task to be
performed in RTL power estimation is the estimation of switching
activity and signal statistics at various signals in the RTL circuit,
Supported by NEC C&C Research Labs
y Supported by NSF under Grant No. MIP-9319269.
that are then fed into the power models for each block to estimate
power consumption.
One of the early architecture level power estimation techniques,
called the power factor approximation (PFA) method [5], characterized
the power consumption in architectural blocks by simulating
their implementations using random input sequences. The
inability of the PFA technique to account for the dependency of
power consumption in embedded modules on their input statistics
was addressed in [6] using a dual bit-type (DBT) model for
word-level signals. Activity-sensitive capacitance models were
developed for various library components, and coupled with zero-delay
activity information derived from RTL simulation to estimate
power consumption. As pointed out in [6], the DBT model is most
applicable to data-flow intensive designs,since it assumes that each
multi-bit signal can be associated with a word-level "value", whose
probability distribution satisfies certain assumptions. In [7, 8], the
use of computational entropy and informational energy as measures
of switching activity was proposed. An activity-based control
model to estimate controller power consumption was presented
in [9].
Most previous work on RT level power estimation has not focused
on control-flow intensive designs, which have significantly
different power consumption characteristics. Unlike data-flow
intensive designs, non-arithmetic components like multiplexers,
registers, vector logic operators, and the controller dominate the
total power consumption. Due to the complex control flow, the
controller has a significant impact on the power consumption of
the circuit, necessitating accurate activity analysis techniques for
control signals. In addition, control-flow intensive designs often
contain multi-bit signals that do not collectively have any meaning
as a "number" and hencecannot be modeled using techniques such
as the DBT model. Previous work has also ignored the presence
of glitching activity at various signals in the RTL circuit, and its
effect on power consumption, which can lead to significant errors
in the power estimates as shown in the following section.
II. Motivation
We illustrate some of the issues involved in RTL power estimation
through the analysis of an example RTL circuit shown
in

Figure

1, that computes the greatest common divisor (GCD) of
two numbers. The RTL blocks used in the GCD data path are one
subtractor, three (one less-than (!) and two equal-to (=)) com-
parators, registers, and multiplexers. The controller is sub-divided
into the state register, the next state logic, and the decode logic
that generates the control signals for the data path. The control
expressions implemented by the decode logic are also shown in

Figure

feeds the select input of the data
path multiplexer marked [i]). The control expressions are logic
expressions involving the decoded state variables x 0 :::x 4
when the controller is in state s i ), and status signals generated by
the data path like the outputs of comparators.
The GCD RTL circuit was mapped to a commercial technology
library, and an in-house simulation-based gate-level power estimation
tool, CSIM [10], was used to monitor the switching activity
OUTPUT
Y YIN
ZERO
CONTROL
SIGNALS
A
RDY
ZERO
ONE
[3]
[6]
[8]
Figure

1: The GCD RTL circuit

Table

1: Activities with/without glitches for various signals of
the GCD circuit
Control Activity Datapath Activity
signal Total W/O Gl. signal Total W/O Gl.
contr[0] 71 70.5 dp2[7::0] 71.5 21.5
contr[1] 22 22 dp4[7::0] 92 26
contr[3] 42 20 dp7[7::0] 1044.5 273
contr[6] 22 22
including and excluding glitches at selected data path and control
signals 1 . The results are reported in Table 1. The numbers shown
in the table demonstrate that switching activity estimates that ignore
glitches can be quite inaccurate for data as well as control
signals.
Known RTL power estimation techniques would compute the
power consumed in each of the RTL blocks in the GCD circuit
using only zero-delay activity information at the block inputs. In
order to explore the ramifications of the above assumption, we
performed the following experiments. First, the entire GCD circuit
implementation was simulated using CSIM and several typical input
sequences, to estimate its average power consumption. The
power consumption was reported to be 1:64mW . Next, we performed
a zero-delay RTL simulation, and collected traces at the
inputs of each embedded circuit block. The implementation of
each RTL block in the GCD circuit was simulated separately (the
controller was considered as a single block) using the signal traces
derived in the previous step, and the individual power estimates
were added up to yield a power estimate of 1:32mW for the entire
circuit (an under-estimate of 19:5%).
Glitches generated at the control signals (outputs of the con-
1 The simulator models each transition as half a
transition, leading to fractional numbers used in examples throughout this
paper. The simulator uses an inertial delay model to capture the effect of
glitch attenuation at gates.
troller) may themselves have a significant impact on the data path
power consumption. In order to study this effect, we performed
another experiment with the GCD RTL circuit, where we collected
zero-delay traces at the controller/data path interface, and used
these traces to estimate power consumption for implementations
of the controller and data path separately. Thus, the effects of
glitches at (i) the data path outputs (status signals) that feed the
controller, and (ii) the controller outputs (control signals) that feed
the data path were ignored for this experiment, while glitch proliferation
within each sub-circuit was considered. The sum of the
individual power estimates for the controller and data path was
1:45mW , indicating that it is important to consider the effects of
glitches on the status and control signals during switching activity
and power estimation for the data path. In comparison, when
we applied the glitching activity and power estimation techniques
presented in this paper to the GCD circuit, we obtained an estimate
of 1:53mW , that corresponds to an error of 6:7% compared to
running CSIM on the entire gate-level circuit.
III. RTL power estimation methodology
The flowchart shown in Figure 2 provides an overview of our
power estimation technique, which consists of three separate
phases. The aim of the first phase is to obtain the zero-delay
signal statistics at various signals in the RTL circuit. We use
cycle-based simulation for this purpose. The test bench can
either be provided by the designer based on an understanding of
the design's functionality and interface, or can be automatically
generated in order to conform to given primary input statistics.
During the simulation run, we monitor the various signals in the
RTL circuit to collect a variety of word- and bit-level statistics. The
advantages of using simulation for this purpose are its flexibility
(e.g. it is relatively easy to use for mixed-level descriptions), and
the high speed of RTL cycle-based simulation.
cycle-based
simulation
Glitching activity
estimation
power
estimation
Glitching
activity
power
models
(controller
Test bench with
typical input traces
zero-delay statistics
Glitch
estimates
Power estimate
Design
Libraries

Figure

2: Overview of our RTL power estimation tool flow
The second phase of our tool augments the zero-delay signal
statistics derived in the first phase by estimating glitching activity
for signals in the RTL circuit (Section IV). Glitching activity
at the output of an RTL block depends on the zero-delay signal
statistics as well as glitching activity at the block's inputs. Hence,
the glitching activity estimation procedure traverses the RTL circuit
starting at primary inputs/register outputs, that are assumed
to be glitch-free, and "propagates" glitching activity information
forward through RTL circuit blocks until we reach primary out-
puts/register inputs.
In the third phase, the zero-delay signal statistics and glitching
activity estimates are used to calculate power consumption in each
module. For this purpose, we have developed power models
for various RTL blocks like functional units, comparators, multi-
plexers, and registers (Section V). These power models capture
the variation of power consumption as a function of zero-delay as
well as glitching activity at the block's inputs. Our procedure for
state[0]
x3
G3
G4

Figure

3: Implementation of control signal contr[1] in the
barcode RTL circuit
the generation and use of power models differs from those presented
in [6] in accounting for glitches, and the fact that we use
bit-level models for RTL blocks that operate on bit-vectors that
may not be associated with a word-level value (e.g. multiplex-
ers, registers, bit-vector concatenation and splitting, vector logic
operations, etc).
IV. Estimating glitching activity at the RT level
In this section, we present our "models" for glitch generation in
and propagation through various components of the RTL circuit.
A. Glitching activity at the control signals
The controller's inputs are the status signals from the data path
(typically outputs of comparators or combinations thereof), while
its outputs are the control signals that feed the data path. The
control logic is usually represented as control expressions during
the high-level synthesis process. These control expressions are
expressed in the form
(1)
where x i represents a decoded controller state variable (corre-
sponding to controller state s i ), Cj represents a status signal,
which is typically the output (or inverted output) of a comparator
from the data path, and
P and
AND operations, respectively. Each product term in the control
expression is derived to flag the occurrence of a particular combination
of values at the status signals when the controller state
is s i . The status signals (Cj) may themselves carry glitches, that
propagate through the control logic, causing the control signals to
be glitchy. On the other hand, the control logic can itself generate
a significant amount of glitching activity.
Accurate estimation of glitch generation and propagation in the
control logic requires detailed information regarding the structure
of the controller implementation and delays. However, the final
implementation of the controller is typically not available during
high-level design iterations. Hence, we estimate glitching activity
at control signals using their control expressions.
Estimating Glitch Generation from Control Expressions.
Glitch generation in the control logic is a result of the interaction
of certain logic and temporal conditions, as illustrated by the
following example.
us consider a portion of an RTL circuit that is a
pre-processor for a barcode reader. We focus on a particular control
signal, contr[1], whose implementation is given in Figure 3.
Signals state[2], state[1] and state[0] are fed by the flip-flops of
the controller. Signals x 3 , x 4 and control signal contr[1] are annotated
with their transition counts including and excluding glitches,
indicating glitch generation at gate G5. Consider the partial state
transition graph for the controller that is shown in Figure 4(a). The
figure indicates a loop involving states s 3 and s 4 , that is executed
a large number of times. Figure 4(b) shows how the inputs and
output of gate G5 vary under these two state transitions. A transition
from s 3 to s 4 causes a rising transition on x 4 and a falling
transition on x 3 . However the rising transition on x 4 arrives later
than the falling transition on x 3 , due to the delays of inverters G1
and G2, resulting in a or glitch at the output
of gate G5. A similar explanation holds for the controller state
transition from s 4 to s 3 . The generation of glitches at G5 can be
attributed to the following two conditions:
x3
x3
(a) (b)

Figure

4: (a) Partial STG for barcode controller, and (b) Generation
of glitches at gate G5
ffl Logic: correlation between (simultaneous occurrence of) rising
and falling transitions at the inputs of G5.
ffl Temporal: the controlling 2 to non-controlling transition at
the input of G5 arrives earlier.
In general, the logic conditions necessary for glitch generation at
a gate are as follows.
ffl There should be at least one rising and at least one falling
transition at the gate's inputs.
should assume a steady controlling logic value.
Assuming an inertial delay model,the temporal condition for glitch
generation in an AND gate is as follows.
ffl The earliest falling transition arrives after the latest rising
transition by an interval that is greater than the gate's inertial
delay.
Similar conditions can be derived for glitch generation in other
types of gates.
Given a control expression in a sum-of-products form (Equa-
tion (1)), during the zero-delay RTL simulation, we maintain a
distinct glitch counter for each product term, and also for the OR
expression combining the product terms. In each cycle, we check
the previous and current values at the variables involved in an AND
or OR expression to see whether the logic conditions for glitch generation
are satisfied. If they are, we increment the corresponding
glitch counter to indicate the possibility of glitch generation in the
current simulation cycle.
As mentioned earlier in this section, checkingwhether the temporal
conditions for glitch generation are satisfied in an accurate
manner requires the final implementation for the control logic,
which is typically not available when performing high-level design
optimizations. One possible approach to tackle the lack of
accurate delay information is to make a pessimistic assumption,
i.e. assume that glitches are generated at a gate whenever the logic
conditions for glitch generation are satisfied. However, such an
assumption often leads to substantial over-estimates of glitching
activity, as shown in the following example.
would like to estimate the glitching activity at
control signal contr[2] in the GCD RTL circuit of Figure 1. The
control expression for contr[2] is x In
this case, the signals C10 and C11 were found to be glitch-free,
simplifying the problem to that of estimating glitch generation at
contr[2].
Clearly, the first product term glitches.
From the simulation traces, we counted the number of times the
logic conditions for glitch generation were satisfied for the second
and third product terms.
controlling input value for a gate uniquely determines the value at
the gate output, irrespective of the values at the gate's other inputs.
In the above equations, the symbols " and # denote the rising
and falling transitions, respectively. From the above numbers,
one could conclude that the glitching activity generated due to
the second and third product terms is 35 and 65, respectively. 3
The glitches generated due to each product term propagate to the
output un-mitigated, since the decoded state variables are mutually
exclusive. From the given traces, it was observed that the logic
conditions for glitch generation at an OR gate were never satisfied
by the outputs of the product terms. Hence, the glitching activity
at control signal contr[2] was estimated to be 100 transitions over
the entire simulation period. A comparison with the glitching
activity observed by CSIM for the same input traces and reported
in

Table

shows that the glitching activity at
was over-estimated by as much as 92:3%!
Although exact arrival time information at various signals is not
available, it is often possible to derive partial information about
delays from RTL descriptions or during high-level synthesis. For
example, the outputs of comparatorscan often be assumedto arrive
later than the decoded present state signals, even when we do not
have any knowledge of their exact arrival times. Inputs to the
control logic are divided into three groups - early arriving signals,
late arriving signals, and signals whose arrival time information is
assumed to be unknown. We assume that each controller input that
is marked as late-arriving arrives significantly later than any input
signal that is marked as early-arriving. No assumption is made
involving the arrival time of a signal marked unknown. Similarly,
no assumption is made about the relationship between the arrival
times of two signals that are both marked either early or late. When
the temporal conditions for glitch generation at a gate involve
signals whose arrival time relationship is unknown, we revert to
the pessimistic approach of only checking logic conditions.
us revisit the control signal contr[2] in the GCD
circuit that was used for the discussions in Example 2. Suppose
we are allowed to make the assumption that the comparator output
signals, C10 and C11, arrive after the decoded state variables,
in the equations
presented above. Since the rising transition arrives later than the
falling transition in this case, the temporal conditions for glitch
generation are not satisfied. Similarly, it can be seen that Case 3
does not satisfy the temporal conditions for glitch generation. The
revised glitching activity estimate for contr[2] is 50, which represents
an error of only 4% with respect to the number reported by
CSIM.
Glitch propagation through the control logic. Consider again
the generic control expression given in Equation (1). Consider
a particular comparator output, C1, that we have predicted to be
glitchy based on our data path glitching activity models. Let us
re-write the control expression by separating the product terms
into terms in which C1 appears, terms in which -
C1 appears, and
terms that do not depend on C1.
C1 (2)
product terms indep: of C1
Y
product terms with C1
Y
product terms with -
Y
3 Note that each time the conditions for glitch generation at a gate are
satisfied, the output undergoes two transitions. However, for compatibility
with CSIM, which counts each transition as half a
transition, we do not multiply by the factor of two.
In order for glitches at C1 to propagate to the control signal, at
least one of the product terms it is involved in must have non-controlling
side-inputs (i.e., 1), and the result of all other product
terms should evaluate to 0. Hence, the following equation can
be utilized to estimate the propagation of glitches to the control
signal.
product terms indep: of C1
Y
In the above equation, Gl(C1) represents the glitching activity at
C1, and is multiplied by the probability that the control signal will
be "sensitized" to glitches at C1. This probability canbe computed
easily during the zero-delay RTL simulation. Equation (3) assumes
that the conditions for glitch generation at C1and the conditions for
the glitches propagating through the control logic are uncorrelated,
which can lead to errors in the estimated activities. We resolve this
problem by maintaining separate data statistics for each state, and
for each signal in the transitive fanin of C1, and hence compute
separate glitching activity estimates for each state [11].30507090
Activity
Estimate
CSIM Activity

Figure

5: Scatter plot of Switching Activity at Control Signals:
Estimate v/s CSIM
In order to get a feel for the accuracy of our switching activity
estimation techniques for control signals, we obtained a
complete gate-level implementation of the GCD circuit and estimated
switching activities using CSIM. The scatter plot shown in

Figure

5 plots the switching activity estimated using our RTL estimation
techniques (y-axis) vs. the switching activity reported by
CSIM (x-axis), for each distinct control signal. As a reference, the
plot also shows a solid line for the equation x. The figure indicates
that our techniques produce estimates that are quite close to
the activity numbers obtained using CSIM after a time-consuming
implementation of the complete GCD controller and data path.
B. Modeling glitch generation and propagation in data path
blocks
For data path blocks which operate on multi-bit input signals
that are associated with a word-level value (e.g. adders, subtrac-
tors, multipliers, and various comparators), previous work [6] has
shown that it is possible to construct activity-sensitive power models
that utilize word-level statistics (mean,standard deviation,etc.
Several data path blocks, however, do not associateany word-level
value to their multi-bit input signals. Common examples of such
blocks are multiplexers, registers, vector logic operations, logic
shift units, etc. We model each bit-slice of such units separately.
This allows us to build more accurate glitching activity models for
such blocks, and to consider the effects of bit-level statistics that
may not be well reflected by word-level signal statistics in certain
situations. Since multiplexers play an important role in glitch
generation and propagation for control-flow intensive designs, we
explain glitching activity model for multiplexers in detail next.
Sel

Figure

Circuit used to study glitch propagation from a multi-
plexer's select input
Sel
G3
OUT

Figure

7: Modeling propagation of glitches from a multiplexer
select signal
Glitch generation and propagation in multiplexers. The glitching
activity at the output of an n-bit multiplexer with data inputs
A and B, select input Sel and output OUT is calculated using the
following equations.
The term Gl Gen(i) in the above equation represents the generation
of glitches in the ith bit-slice of the multiplexer, and
is calculated as follows. The number of distinct input vector
pairs that can be applied at A i ,
Since the above number is small, we simulate the implementation
of a 1-bit multiplexer for the exhaustive set of 64 input
vector pairs, and build a look-up table that stores the glitches
generated for each vector pair. The lookup table can be thought
of as a six-dimensional array Mux gl gen[], and the entry of
the table corresponding to present and previous input values
1)]. During the zero-delay RTL simulation phase, we accrue the
glitch generation at each bit-slice of a multiplexer by looking up
the appropriate entry of the Mux gl gen[] table.
The output of a multiplexer can also be glitchy due to the
propagation of glitches from the data and select inputs. The terms
Gl Prop A i and Gl Prop B i in Equation (4) represent the glitch
propagation from A i and B i , respectively, and are computed using
the following equations.
Gl Prop A
In order to study the propagation of glitches from the select signal
of a multiplexer, we implemented the circuit shown in Figure 6,
where the embedded multiplexer's select input is glitchy while its
data inputs are not. Figure 7 shows a bit-slice of the multiplexer,
and a table that reports the activity at OUT i for all possible values
of A i and B i . In the ! 0; 0 ? case, glitches on select signal Sel
are killed at AND gates G1 and G2 due to controlling side inputs
that arrive early. When data inputs are ! 0; 1 ? (!
glitches on Sel propagate through gates G2 and G3 (G1 and G3).
Finally, when data inputs are ! 1; 1 ?, glitches on Sel propagate
through gates G1 and G2. The output of the multiplexer is glitchy
as a result of the interaction of the glitchy signal waveforms at
G1 and G2. We conclude that the glitch propagation from the
select input of a multiplexer to its output is affected by the spatial
correlation between the data inputs. Hence, simply measuring the
signal probabilities at each data input bit to a multiplexer will not
suffice.
Our model for glitch propagation from the select signal of the
multiplexer to its output is given by the following equation.
Gl (D 01   P
The probabilities P
are monitored for each multiplexer bit-slice
during the zero-delay simulation phase. The constants D 01 ,
and D 11 depend on the exact implementation of the multiplexer,
and are computed by performing experiments using the circuit
configuration shown in Figure 6.
Word-level models for glitching activity. We next focus on
data path blocks that operate on multi-bit input signals that are
associated with a word-level value (e.g. adders, subtractors, mul-
tipliers, and various comparators). The glitching activity at the
output of an embedded data path block depends on its functionality
as well as its implementation details, zero-delay statistics at
the input signals (e.g. mean, standard deviation, spatial and temporal
correlations in the case of signals with a numeric value), and
glitching activity at the inputs themselves. We construct glitch
models from the implementations of various library components
through a process of characterization. We perform controlled experiments
(simulation runs) by selectively varying one or more of
the controllable variables (input zero-delay statistics and glitching
activities), and observing the value of the dependent variable
(glitching activity at the block output). Given the set of samples
obtained from the characterization experiments, there are several
statistical techniques that can be used to build a model that predicts
the output glitching activity [12]. An approach that we have found
to be flexible and suited to automation is the use of one or more
piecewise linear models for capturing the relationship between
glitches and the various controllable variables. We illustrate the
process of deriving the glitching activity models for the case of an
8-bit subtractor with inputs named A and B, and output OUT . In
general, the glitching activity at OUT can be written as
The first seven parameters of f() represent the zero-delay signal
statistics at A and B. MeanA represents the mean or expected
word-level value represented by signal A, SDA represents its
standard deviation,T CA is the temporal correlation coefficient that
represents the correlation between consecutive values that appear
at signal A, SCA;B is the spatial correlation coefficient of A and
B. GlA represents the glitching activity at A. Parameters with
subscripts B have a similar meaning. The brute-force approach
for building a model for fgl() would involve discretizing the range
of variation of each of the parameters with a desired granularity,
generating input sequences that correspond to each possible set of
values for the parameters, and simulating the implementation of
the subtractor to observe the glitching activity at the subtractor's
output for each case. Assuming that each parameter can assume k
possible values, the above approach will require k n simulations,
where n is the number of parameters or independent variables
considered. In the case of the even assuming
leads to 1:95 million simulation runs! Clearly, the brute-force
approach is undesirable, in spite of the fact that building the
models is a one-time cost for a given component library. We use
two techniques to avoid the combinatorial explosion in the number
of simulation runs required.
MEAN A
OUTPUT
GLITCHING
STANDARD DEVIATION A STANDARD
CORRECTION
TEMPORAL CORRELATION A TEMPORAL
CORRELATION B
CORRECTION
(a) (b) (c)0.20.610
CORRECTION
SPATIAL CORRELATION COEFFICIENT
GLITCHING ACTIVITY A
GLITCHING
CORRECTION
(d) (e)

Figure

8: Glitching activity models for an 8-bit subtractor
The first technique, called variable elimination, attempts to reduce
the number of independent variables in the glitching activity
model by identifying ones whose variations affect the dependent
variable (output glitches) minimally. We use techniques from
multi-variable data analysis for this purpose. Given a set of samples
(each sample consists of a set of values for the independent
variables y 1 :::y n , and the corresponding observed value that the
dependent variable (z) assumes), we can use the ANOVA test 4 to
check whether the null hypothesis for any given variable y i is true,
i.e., whether different values of y i had any impact on the observed
sample values of z [12].
The second technique, called model decomposition, attempts to
decompose the function f() into multiple sub-functions by partitioning
the set of parameters into smaller groups of variables such
that the effects of variables from different groups on the dependent
variable interact minimally. Again, it is possible to use standard
ANOVA techniques to obtain a quantitative evaluation of the inter-action
of the effects of two independent variables on the dependent
variable from a given set of samples.
In the case of the subtractor, we found that the basic model of
Equation (5) can be decomposed into the following equation.
The independent variables have been partitioned in the above
equation into the groups, fMeanA ; MeanBg, fSDA ; SDBg,
GlBg. The above partition
was basedon the observation that variables within eachgroup have
a significant interaction in their effect on the dependent variable,
while the variables in distinct groups are reasonably independent
in their effects. As before, assuming we discretize the domain for
each parameter into 5 distinct regions, we would need to perform
simulations for different sets of
4 ANOVA stands for Analysis Of VAriance, which is a popular technique
used for statistical inference and testing.
parameter values, which can be performed much more efficiently
compared to the approach of building a single huge piecewise
linear model from Equation (5).
Note that the sub-functions are composed using a multiplicative
relationship. Hence, we can view one of the sub-functions,
say fgl 1 () as a base glitch model, and the remaining sub-functions
as multiplicative correction factors. The base glitch model in the
form of a contour plot is shown in Figure 8(a). Consider the
sub-function fgl 2 (SDA ; SDB ). In order to construct the model
for this sub-function, we discretize the range of variation of SDA
and SDB into a finite number of uniformly spaced points. For
each point, that corresponds to distinct values for SDA and SDB ,
we construct long vector sequences that have the desired values
for SDA and SDB . Well-known algorithms exist to generate
sequenceswhose means, standard deviations, and spatial and temporal
correlations conform to desired values [13]. The subtractor
implementation is simulated using CSIM and the values of glitching
activity at the output are recorded. The plot in Figure 8(b)
shows the results. The values in the plot are normalized to the case
of since the base power model (fgl 1 ()) was
derived assuming SDA and SDB to be fixed to 25:6. Given the
values of SDA and SDB for an embedded subtractor, the value of
is estimated from the values at the four points nearest to it
in the discretized SDA ; SDB space, using standard linear intrap-
olation techniques. The models for fgl 3 ():::fgl 5 () are provided in

Figures

8(c) through 8(e).
In order to generate the model for fgl 5 (), we needed to generate
input sequencesto the subtractor that have varying glitching activities
at A andB. In order to do that, we useda circuit configuration
similar to that shown in Figure 6. We added two multiplexers to
feed the inputs of the subtractor, and connected their select input to
the output of a (!) comparator. Given a sequence of inputs to the
(!) comparator that is known to generate glitches, we can control
the glitches at the outputs of the multiplexers through the spatial
correlations at their inputs, as illustrated earlier in this subsection.
V. RTL Power Models
Given the zero-delay and glitching activity estimates obtained
from the first two phases of the tool, the third phase uses several
MEAN A
POWER
CONSUMPTION
STANDARD DEVIATION A STANDARD
CORRECTION
CORRELATION B
CORRECTION
(a) (b) (c)0.20.610.2 0.4 0.6 0.8 1
CORRECFION
SPATIAL CORRELATION A-B
GLITCHING
CORRECTION
(d) (e)

Figure

9: Word-level power models for a less-than (!) comparator
word- and bit-level power models that we discuss in this section.
Word-level power modeling techniques. The process of deriving
power models is similar to that of deriving glitching activity
models, except that the dependent variable now becomes the total
power consumption as opposed to the glitching activity at the output
of the block. As explained in Subsection IV.B, we attempt to
simplify the modeling process by using the techniques of variable
elimination and model decomposition.
As an example, consider an 8-bit less-than (!) comparator. The
power model for the (!) comparator was decomposed into sub-
functions, and the model for each sub-function is illustrated by the
plots in Figure 9. Note that glitchy inputs can cause a substantial
increase in the power consumption of the comparator, as shown
in

Figure

9(e), confirming the importance of considering glitching
activity at the inputs of various RTL blocks during estimation.
Bit-level power models. For data path blocks which do not associate
any word-level value to their multi-bit input signals, we
derive power models that use the bit-level signal and transition
probabilities, correlations and glitching activity to calculate power
consumption in each bit-slice of the block separately. For exam-
ple, the power consumption in an n-bit multiplexer is modeled as
follows.
Base Power(i) (7)
+Sel Gl Power(i)
A Gl
Sel Gl
The term Base Power represents the power consumption in the
multiplexer ignoring glitching activity at its inputs. The remaining
three terms are additive correction factors used to capture the effect
of glitches at the select and data inputs. As with the case of the
glitch generation model, we apply all 64 possible vector pairs to
a 1-bit multiplexer, measure the power consumption using CSIM,
and store the results in the form of a table called Mux Power[].
During the RTL zero-delay simulation phase,we look up the entries
of this table using the present and previous values at the inputs of
each multiplexer bit-slice to calculate the Base Power term.
The presence of glitches at the select input can significantly
increase the power consumption in the multiplexer. We model
the power consumption separately for the cases when the data inputs
are 00, 01, 10, and 11. The coefficients KSel00 ; :::; KSel11
are obtained by performing controller experiments with the circuit
configuration shown in Figure 6 by fixing the multiplexer data inputs
to 00, 01, 10, and 11 (note that even when glitches at Sel do
not propagate to the output, they could cause power dissipation internal
to the multiplexer). The purposeof the A Gl Power(i) and
Gl Power(i) is to similarly account for the effect of glitching
activity at A i and B i .
The power model for an n-bit register that has a data input IN ,
a clock input CLK , and output OUT is given by the following
equation.
The first term accounts for the power dissipated due to the clock
line switching. The value of KCLK is measured by simulating the
implementation of a register while holding the value of IN con-
stant. The second term accounts for the power dissipated when the
value stored in the register changes. The value of KOUT i
is determined
by simulating the register under a long, glitch-free input
sequence, subtracting the contribution of the clock transitions, and
dividing the residual power per bit-slice by the average bit-level
activity at the output of the register. The last term models the effect
of glitches at the input of a register. The value of KIN i
is determined
by simulating the register under a glitchy input sequence
and subtracting estimates for the effect of the first two terms. Note
that usually KOUT i
for all
Controller power estimation. In order to obtain an estimate for
the total RTL circuit power consumption, we must also estimate
the power consumptionin the controller. Asmentioned previously,
the complete controller implementation is typically not available
until logic synthesis optimizations have been performed. Hence,
it is difficult to obtain an accurate estimate of the controller power.
In [6], models for controller power were proposed based on the
target implementation style (e.g. PLA, ROM, Standard Cell),
and the number of states, inputs, and outputs of the controller.
The controller consists of a state register, next state logic, and
(or output) logic. Control expressions are typically used
to represent the functionality of the next-state logic and decode
logic during high-level synthesis. For the purposes of estimating
controller power, we assume that the next state and decode logic
are implemented in a straightforward manner from their control
expressions. The zero-delay switching activity at various signals
in the controller is monitored during the RTL simulation. Later,
we estimate glitching activity using the control expressions as
explained in Subsection IV.A. We multiply the total activity at
the output of each gate in the controller with approximate values
for gate output capacitance (we assume typical values for a 2-
input AND gate, 2-input OR gate, and INVERTER) to yield a power
consumption estimate for the controller. The power consumption
in the state register is estimated using the model for register power
presented earlier.
VI. Experimental results
We performed experiments in order to evaluate the proposed
power estimation techniques using the following
cuits: the GCD circuit shown in Figure 1 [14], the barcode
preprocessor [14], and a circuit implementing a part of the X.25
communications protocol [15]. All the RTL circuits were obtained
by synthesizing them from control-flow intensive specifications
using the SECONDS high-level synthesis system [4, 15].
We built glitching activity as well as power models for the
components of the RTL library used by SECONDS. For the first
phase of our power estimation tool (zero-delay RTL simulation),
we used a test bench that was derived using the knowledge of the
functionality of the design and its environment. As the simulation
proceeded, zero-delay statistics for various signals were collected.
The zero-delay statistics were then used for predicting glitching
activity at various data path and control signals using the models
presented in previous sections. Thereafter, zero-delay and glitch
statistics were used to calculate a number for power consumption
for each data path block and for the controller. We performed logic
synthesis optimizations on the controller, mapped the controller
and data path to a commercial 0:8 micron technology library, and
estimated power consumption using the tool CSIM.
We performed experiments to demonstrate the following claims
(i) the estimates obtained by our RTL power estimation tool compared
favorably to estimates obtained using CSIM, and (ii) the
importance of estimating glitching activity and using it to enhance
the accuracy of power estimates for the various RTL circuit blocks.

Table

2 reports the power estimates obtained using CSIM after a
complete gate-level implementation of the RTL circuit (column
CSIM), RTL power estimates obtained using our tool (column
estimates obtained by ignoring the effects of

Table

2: Experimental Results
Circuit CSIM RTL Est. RTL Est. W/O Gl.
Pow. %Err Pow. %Err
GCD 1.64mW 1.53mW 6.71 1.28mW 21.95
Bar- 2.82mW 2.94mW 4.25 2.41mW 14.54
code
glitching activity at the control and data path signals (column RTL
Est. W/O Gl. In order to obtain RTL power estimates ignoring
the effects of glitches, we used our tool but instructed it to not
perform the second phase of glitching activity estimation. Note
that the estimates thus obtained do include the effects of glitches
within each RTL block. For the second and third cases, the table
reports the power estimate as well as the percentage error with
respect to CSIM.
The results indicate that the proposed RTL switching activity
and power estimation techniques result in power estimates that
range from within 4:25% to within 6:71% of those obtained after
the final gate-level implementation of the circuit. The results also
demonstrate the importance of considering glitching activity at
control and data path signals during RTL power estimation.



--R

"Accurate layout area and delay modeling for system level design,"
"Timing analysis in high-level synthesis,"
"Rapid estimation for parameterized components in high-level synthesis,"
"Provably correct high-level timing analysis without path sensitization,"
"Estimating power dissipation of VLSI signal processing chips: the PFA technique,"
"Architectural power analysis: the dual bit type method,"
"Information theoretic measures for energy consumption at the register-transfer level,"
"Towards a high-level power estimation capability,"
"Activity-sensitive architectural power analysis for the control path,"
CSIM Version 5 Users Manual.
"Register-trasfer level estimation techniques for switching activity and power consumption,"
Duxbury Press
The Art of Computer Programming
Research Triangle Park
"Performance analysis and optimization of schedules for conditional and loop-intensive spec- ifications,"
--TR
Provably correct high-level timing analysis without path sensitization
Performance analysis and optimization of schedules for conditional and loop-intensive specifications
Architectural power analysis
Information theoretic measures of energy consumption at register transfer level
Towards a high-level power estimation capability
Activity-sensitive architectural power analysis for the control path
The art of computer programming, volume 2 (3rd ed.)
Timing analysis in high-level synthesis
Accurate layout area and delay modeling for system level design

--CTR
Subodh Gupta , Farid N. Najm, Energy-per-cycle estimation at RTL, Proceedings of the 1999 international symposium on Low power electronics and design, p.121-126, August 16-17, 1999, San Diego, California, United States
Alessandro Bolgiolo , Roberto Corgnati , Enrico Macii , Massimo Poncino, Parameterized RTL power models for soft macros, IEEE Transactions on Very Large Scale Integration (VLSI) Systems, v.9 n.6, p.880-887, 12/1/2001
Srinivas Bodapati , Farid Najm, Frequency-domain supply current macro-model, Proceedings of the 2001 international symposium on Low power electronics and design, p.295-298, August 2001, Huntington Beach, California, United States
A. Bogliolo , L. Benini , B. Ricc , G. De Micheli, Efficient switching activity computation during high-level synthesis of control-dominated designs, Proceedings of the 1999 international symposium on Low power electronics and design, p.127-132, August 16-17, 1999, San Diego, California, United States
Jing-Yuan Lin , Wen-Zen Shen , Jing-Yang Jou, A power modeling and characterization method for macrocells using structure information, Proceedings of the 1997 IEEE/ACM international conference on Computer-aided design, p.502-506, November 09-13, 1997, San Jose, California, United States
Tony D. Givargis , Frank Vahid , Jrg Henkel, Instruction-based system-level power evaluation of system-on-a-chip peripheral cores, Proceedings of the 13th international symposium on System synthesis, September 20-22, 2000, Madrid, Spain
Luca Benini , Alessandro Bogliolo , Enrico Macii , Massimo Poncino , Mihai Surmei, Regression-based RTL power models for controllers, Proceedings of the 10th Great Lakes symposium on VLSI, p.147-152, March 02-04, 2000, Chicago, Illinois, United States
Tony Givargis , Frank Vahid , Jrg Henkel, System-level exploration for pareto-optimal configurations in parameterized systems-on-a-chip, Proceedings of the 2001 IEEE/ACM international conference on Computer-aided design, November 04-08, 2001, San Jose, California
Subodh Gupta , Farid N. Najm, Energy and peak-current per-cycle estimation at RTL, IEEE Transactions on Very Large Scale Integration (VLSI) Systems, v.11 n.4, p.525-537, August
Jouml;rg Henkel , Yanbing Li, Energy-conscious HW/SW-partitioning of embedded systems: a case study on an MPEG-2 encoder, Proceedings of the 6th international workshop on Hardware/software codesign, p.23-27, March 15-18, 1998, Seattle, Washington, United States
V. Jerini , D. Mller, Safe integration of parameterized IP, Integration, the VLSI Journal, v.37 n.4, p.193-221, September 2004
Kamal S. Khouri , Ganesh Lakshminarayana , Niraj K. Jha, Fast high-level power estimation for control-flow intensive design, Proceedings of the 1998 international symposium on Low power electronics and design, p.299-304, August 10-12, 1998, Monterey, California, United States
Prashant Agrawal , Srinivasa R. STG , Ajit N. Oke , Saurabh Vijay, A path based modeling approach for dynamic power estimation, Proceedings of the 17th great lakes symposium on Great lakes symposium on VLSI, March 11-13, 2007, Stresa-Lago Maggiore, Italy
Subodh Gupta , Farid N. Najm, Power macromodeling for high level power estimation, Proceedings of the 34th annual conference on Design automation, p.365-370, June 09-13, 1997, Anaheim, California, United States
Anand Raghunathan , Sujit Dey , Niraj K. Jha , Kazutoshi Wakabayashi, Power management techniques for control-flow intensive designs, Proceedings of the 34th annual conference on Design automation, p.429-434, June 09-13, 1997, Anaheim, California, United States
Rita Yu Chen , Mary Jane Irwin , Raminder S. Bajwa, Architecture-level power estimation and design experiments, ACM Transactions on Design Automation of Electronic Systems (TODAES), v.6 n.1, p.50-66, Jan. 2001
Zhanping Chen , Kaushik Roy, A power macromodeling technique based on power sensitivity, Proceedings of the 35th annual conference on Design automation, p.678-683, June 15-19, 1998, San Francisco, California, United States
Srinivas Bodapati , Farid N. Najm, High-level current macro-model for power-grid analysis, Proceedings of the 39th conference on Design automation, June 10-14, 2002, New Orleans, Louisiana, USA
Zhanping Chen , Kaushik Roy , Edwin K. P. Chong, Estimation of power sensitivity in sequential circuits with power macromodeling application, Proceedings of the 1998 IEEE/ACM international conference on Computer-aided design, p.468-472, November 08-12, 1998, San Jose, California, United States
K. S. Khouri , G. Lakshminarayana , N. K. Jha, IMPACT: a high-level synthesis system for low power control-flow intensive circuits, Proceedings of the conference on Design, automation and test in Europe, p.848-854, February 23-26, 1998, Le Palais des Congrs de Paris, France
B. Alorda , V. Canals , J. Segura, A Two-Level Power-Grid Model for Transient Current Testing Evaluation, Journal of Electronic Testing: Theory and Applications, v.20 n.5, p.543-552, October 2004
Anand Raghunathan , Sujit Dey , Niraj K. Jha, High-level macro-modeling and estimation techniques for switching activity and power consumption, IEEE Transactions on Very Large Scale Integration (VLSI) Systems, v.11 n.4, p.538-557, August
Youn-Long Lin, Recent developments in high-level synthesis, ACM Transactions on Design Automation of Electronic Systems (TODAES), v.2 n.1, p.2-21, Jan. 1997
